# Hexagonal Orders Application

## Overview
This project demonstrates a Spring Boot application implementing the Hexagonal Architecture (also known as Ports and Adapters) with the **Outbox Pattern** for reliable event publishing. The application manages orders and order items, showcasing clean architecture principles, separation of concerns, and reliable event-driven communication.

## Key Features
- **Hexagonal Architecture**: Clean separation between domain, application, and infrastructure layers
- **Outbox Pattern**: Reliable event publishing with transactional consistency
- **Order Lifecycle Management**: Create orders in PENDING status and confirm them to trigger integration events
- **Domain Events & Integration Events**: Clear separation between internal domain events and external integration events
- **Comprehensive Testing**: Unit tests, integration tests, and end-to-end testing
- **Event-Driven Design**: Domain events for loose coupling between components
- **RESTful API**: Fully documented with Swagger/OpenAPI

## Project Structure
```
src/main/java/com/example/hexagonalorders/
├── domain/                    # Domain Layer (Core Business Logic)
│   ├── model/                # Domain Entities & Value Objects
│   │   ├── Order.java
│   │   ├── OrderItem.java
│   │   ├── OrderStatus.java
│   │   ├── OutboxMessage.java
│   │   ├── OutboxStatus.java
│   │   └── valueobject/
│   │       ├── OrderNumber.java
│   │       ├── ProductNumber.java
│   │       └── Quantity.java
│   ├── event/                # Domain Events
│   │   ├── DomainEvent.java
│   │   ├── OrderCreatedEvent.java
│   │   ├── OrderConfirmedEvent.java
│   │   └── OrderItemAddedEvent.java
│   ├── port/                 # Domain Ports (Business Logic Interfaces)
│   │   ├── in/              # Input Ports (Use Cases)
│   │   │   └── OrderUseCase.java
│   │   └── out/             # Output Ports (Repositories, Services)
│   │       ├── OrderRepository.java
│   │       ├── OrderNumberGenerator.java
│   │       ├── OutboxRepository.java
│   │       └── MessagePublisher.java
│   └── service/             # Domain Services
│       └── OrderValidationService.java
├── application/              # Application Layer (Use Cases)
│   ├── service/             # Application Services
│   │   └── OrderService.java
│   ├── handler/             # Event Handlers
│   │   └── DomainEventHandler.java
│   ├── event/               # Integration Events
│   │   └── OrderConfirmedIntegrationEvent.java
│   └── exception/           # Application Exceptions
│       └── OrderNotFoundException.java
├── infrastructure/           # Infrastructure Layer
│   ├── config/              # Configuration
│   │   └── OrderConfiguration.java
│   ├── in/                  # Input Adapters (Primary/Driving)
│   │   └── web/            # Web Adapters
│   │       ├── OrderController.java
│   │       ├── dto/        # Data Transfer Objects
│   │       │   ├── OrderDto.java
│   │       │   └── OrderItemDto.java
│   │       └── mapper/     # DTO Mappers
│   │           └── OrderMapper.java
│   └── out/                # Output Adapters (Secondary/Driven)
│       ├── persistence/    # Persistence Adapters
│       │   ├── entity/     # JPA Entities
│       │   │   ├── OrderJpaEntity.java
│       │   │   ├── OrderItemJpaEntity.java
│       │   │   ├── OrderStatus.java
│       │   │   └── OutboxJpaEntity.java
│       │   ├── repository/ # JPA Repositories
│       │   │   ├── OrderJpaRepository.java
│       │   │   ├── OrderRepositoryAdapter.java
│       │   │   ├── OutboxMessageJpaRepository.java
│       │   │   └── OutboxRepositoryAdapter.java
│       │   └── mapper/    # Entity Mappers
│       │       ├── OrderJpaMapper.java
│       │       └── OutboxMessageMapper.java
│       ├── event/          # Event Processing
│       │   └── OutboxProcessor.java
│       ├── messaging/      # Message Publishing
│       │   └── NoOpMessagePublisher.java
│       └── orderNumber/   # Order Number Generation Adapters
│           └── UuidOrderNumberGenerator.java
└── HexagonalOrdersApplication.java
```

## Technologies Used
- **Java 21**
- **Spring Boot 3.2.3**
- **Spring Data JPA**
- **H2 Database**
- **Lombok**
- **Maven**
- **Springdoc OpenAPI (Swagger UI)**
- **Jackson JSR310** (for LocalDateTime serialization)

## Getting Started
1. Clone the repository
2. Build the project:
   ```bash
   mvn clean install
   ```
3. Run the application:
   ```bash
   mvn spring-boot:run
   ```

## API Endpoints
- `POST /api/orders` - Create a new order (no `id` or `orderNumber` in the request; both are generated by the backend)
  - Required fields in the request body now include shipping address fields: `street`, `city`, `state`, `postalCode`, `country`.
  - Orders are created in `PENDING` status and do not trigger external integration events
- `GET /api/orders/{orderNumber}` - Get order by order number
- `POST /api/orders/{orderNumber}/confirm` - Confirm an order (changes status from PENDING to CONFIRMED)
  - This operation triggers an `OrderConfirmedIntegrationEvent` that is published to external systems via the `DomainEventHandler`
- `DELETE /api/orders/{orderNumber}` - Delete an order

### Example: Create Order Request Payload
```json
{
  "customerId": "CUST-001",
  "orderDate": "2024-06-18T10:00:00",
  "items": [
    {
      "productNumber": "PROD-001",
      "quantity": 2,
      "unitPrice": 19.99
    }
  ],
  "status": "PENDING",
  "street": "123 Main St",
  "city": "Springfield",
  "state": "IL",
  "postalCode": "62704",
  "country": "USA"
}
```

## H2 Database Console
The application uses H2 as an in-memory database. You can access the H2 console at:
- URL: http://localhost:8080/h2-console
- JDBC URL: jdbc:h2:mem:testdb
- Username: sa
- Password: (empty)

## API Documentation (Swagger/OpenAPI)
- The API is documented using Swagger/OpenAPI annotations.
- The `OrderDto` now includes required shipping address fields: `street`, `city`, `state`, `postalCode`, `country`.
- Access the interactive documentation at:
  - http://localhost:8080/swagger-ui.html
  - or http://localhost:8080/swagger-ui/index.html
- The input and output DTOs (`OrderDto`, `OrderItemDto`) are documented to indicate which fields are generated by the backend and which are required in the request.

## Domain Events vs Integration Events

### Overview
The application implements a clear separation between **Domain Events** and **Integration Events** to maintain clean architecture boundaries and stable external contracts.

### Domain Events
- **Purpose**: Internal communication within the domain model
- **Scope**: Used for loose coupling between aggregates and domain services
- **Examples**: `OrderCreatedEvent`, `OrderConfirmedEvent`, `OrderItemAddedEvent`
- **Persistence**: Not persisted to outbox (internal only)

### Integration Events
- **Purpose**: External communication with other systems
- **Scope**: Used for system-to-system integration
- **Examples**: `OrderConfirmedIntegrationEvent`
- **Persistence**: Persisted to outbox for reliable delivery
- **Mapping**: Created from domain events in the application layer

### Event Flow
1. **Domain Event**: Raised by domain model (e.g., `OrderConfirmedEvent`)
2. **Event Handler**: `DomainEventHandler` listens for domain events and maps them to integration events
3. **Outbox**: Integration event is persisted for reliable delivery
4. **External Systems**: Receive integration events via message broker

## Outbox Pattern Implementation

### Overview
The application implements the **Outbox Pattern** to ensure reliable event publishing across system boundaries. This pattern guarantees that domain events are never lost, even if the external message broker is temporarily unavailable.

### How It Works
1. **Event Persistence**: When a domain event occurs, it's persisted to the `outbox` table in the same transaction as the business data
2. **Reliable Processing**: A background processor (`OutboxProcessor`) polls for pending messages and publishes them to external systems
3. **Idempotency**: Messages are processed with idempotency guarantees using composite indexes
4. **Error Handling**: Failed messages are marked and can be retried

### Key Components
- **OutboxMessage**: Domain model representing a message in the outbox
- **OutboxRepository**: Interface for outbox operations
- **OutboxProcessor**: Scheduled component that processes pending messages
- **MessagePublisher**: Interface for publishing messages to external systems
- **NoOpMessagePublisher**: Development implementation that logs messages to console

### Database Schema
```sql
CREATE TABLE outbox (
    id UUID PRIMARY KEY,
    aggregate_id UUID NOT NULL,
    aggregate_type VARCHAR(255) NOT NULL,
    event_type VARCHAR(255) NOT NULL,
    payload CLOB NOT NULL,
    status VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    processed_at TIMESTAMP
);

CREATE INDEX idx_outbox_idempotency ON outbox (aggregate_id, event_type, created_at);
```

## Testing Strategy

### Test Types
1. **Unit Tests**: Test individual components in isolation
2. **Integration Tests**: Test the interaction between components
3. **End-to-End Tests**: Test complete user workflows

### Test Classes
- **OrderControllerIntegrationTest**: True integration tests using `@SpringBootTest` with real database operations
- **OrderServiceWithOutboxTest**: Service layer tests focusing on outbox persistence
- **OutboxIntegrationTest**: End-to-end testing of the outbox pattern

### Running Tests
```bash
# Run all tests
mvn test

# Run specific test class
mvn test -Dtest=OrderControllerIntegrationTest

# Run specific test method
mvn test -Dtest=OrderControllerIntegrationTest#createOrder_ShouldTriggerOutboxProcessing
```

### Test Configuration
- Uses H2 in-memory database for testing
- `@Transactional` for test isolation
- Jackson JSR310 module for LocalDateTime serialization
- Manual outbox processing for predictable test results

## Hexagonal Architecture Benefits
This project implements Hexagonal Architecture (Ports and Adapters) and provides several benefits:
1. **Domain-Centric Design**: The business logic is isolated from external concerns
2. **Clear Boundaries**: The architecture enforces clear boundaries between layers
3. **Testability**: Each layer can be tested independently
4. **Flexibility**: External dependencies can be easily swapped (e.g., database, UI, message broker)
5. **Maintainability**: Changes in one layer do not affect others
6. **Event-Driven**: Loose coupling through domain events
7. **Reliability**: Outbox pattern ensures no events are lost

## Architecture Notes
- **Domain Ports** (`port/in` and `port/out`) are only for business logic and persistence/service abstractions, not for web or infrastructure concerns.
- **OrderController** is implemented directly in the infrastructure layer as a REST adapter, not as a domain port.
- **Domain Events** are used for loose coupling between aggregates and external systems.
- **DomainEventHandler** provides centralized event handling and integration event mapping, maintaining separation of concerns.
- **Outbox Pattern** ensures reliable event publishing without compromising transactional consistency.
- This structure keeps the domain layer free from any dependencies on frameworks or delivery mechanisms.

## DomainEventHandler Pattern

### Overview
The application uses a dedicated `DomainEventHandler` class to centralize the mapping of domain events to integration events. This pattern provides several benefits:

### Benefits
- **Separation of Concerns**: Event handling logic is separated from business logic
- **Centralized Event Mapping**: All integration event creation is handled in one place
- **Automatic Event Processing**: Uses Spring's `@EventListener` for automatic event handling
- **Maintainability**: Easy to add new event handlers without modifying business services
- **Testability**: Event handlers can be tested independently

### Implementation
- **@EventListener**: Automatically listens for domain events published via Spring's `ApplicationEventPublisher`
- **Event Mapping**: Maps domain events to appropriate integration events
- **Outbox Persistence**: Persists integration events to the outbox for reliable delivery
- **Error Handling**: Includes proper error handling and logging for event processing

## Event Flow Examples

### Order Creation Flow
1. **Order Creation**: `POST /api/orders` creates an order in PENDING status
2. **Domain Event**: `OrderCreatedEvent` is raised internally (not persisted to outbox)
3. **Transaction**: Order data is saved atomically
4. **Response**: Order is returned to client with generated orderNumber

### Order Confirmation Flow
1. **Order Confirmation**: `POST /api/orders/{orderNumber}/confirm` confirms an order
2. **Domain Event**: `OrderConfirmedEvent` is raised by the domain model
3. **Event Handler**: `DomainEventHandler` automatically listens for the domain event and creates `OrderConfirmedIntegrationEvent`
4. **Transaction**: Order status update and integration event are saved atomically to outbox
5. **Processing**: `OutboxProcessor` picks up the pending integration event
6. **Publishing**: Integration event is published via `MessagePublisher` (logged to console in development)
7. **Completion**: Message is marked as processed

## Contributing
1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License
This project is licensed under the MIT License - see the LICENSE file for details.

## Sequence Diagrams

### Order Creation Flow

The following sequence diagram illustrates the complete flow when creating an order through the REST API:

```mermaid
sequenceDiagram
    participant Client
    participant OrderController
    participant OrderMapper
    participant OrderService
    participant OrderValidationService
    participant OrderNumberGenerator
    participant OrderRepository
    participant OrderJpaMapper
    participant OrderJpaRepository
    participant Database

    Note over Client, Database: Order Creation Flow

    Client->>OrderController: POST /api/orders
    Note right of Client: OrderDto (customerId, items, status)

    OrderController->>OrderMapper: toDomain(orderDto)
    OrderMapper-->>OrderController: Order (without orderNumber)

    OrderController->>OrderService: createOrder(order)
    
    OrderService->>OrderValidationService: validateOrder(order)
    OrderValidationService-->>OrderService: validation result

    OrderService->>OrderNumberGenerator: generate()
    OrderNumberGenerator-->>OrderService: OrderNumber

    OrderService->>OrderService: new Order(orderNumber, ...)
    Note right of OrderService: Creates Order with OrderCreatedEvent (internal only)

    OrderService->>OrderRepository: save(orderWithNumber)
    
    OrderRepository->>OrderJpaMapper: toJpaEntity(order)
    OrderJpaMapper-->>OrderRepository: OrderJpaEntity

    OrderRepository->>OrderJpaRepository: save(orderJpaEntity)
    OrderJpaRepository->>Database: INSERT INTO orders
    Database-->>OrderJpaRepository: saved order
    OrderJpaRepository-->>OrderRepository: OrderJpaEntity

    OrderRepository-->>OrderService: saved Order

    OrderService->>OrderService: clearDomainEvents()
    OrderService-->>OrderController: saved Order

    OrderController->>OrderMapper: toDto(savedOrder)
    OrderMapper-->>OrderController: OrderDto

    OrderController-->>Client: 200 OK + OrderDto

    Note over Client, Database: Transaction Boundary
    Note over OrderService, Database: All database operations are in the same transaction
```

### Order Confirmation Flow

The following sequence diagram illustrates the complete flow when confirming an order:

```mermaid
sequenceDiagram
    participant Client
    participant OrderController
    participant OrderService
    participant DomainEventHandler
    participant OrderRepository
    participant OrderJpaMapper
    participant OrderJpaRepository
    participant OutboxRepository
    participant OutboxJpaRepository
    participant OutboxProcessor
    participant MessagePublisher
    participant Database

    Note over Client, Database: Order Confirmation Flow with Outbox Pattern

    Client->>OrderController: POST /api/orders/{orderNumber}/confirm

    OrderController->>OrderService: confirmOrder(orderNumber)
    
    OrderService->>OrderRepository: findByOrderNumber(orderNumber)
    OrderRepository->>OrderJpaRepository: findByOrderNumber()
    OrderJpaRepository->>Database: SELECT FROM orders WHERE orderNumber = ?
    Database-->>OrderJpaRepository: order data
    OrderJpaRepository-->>OrderRepository: OrderJpaEntity
    OrderRepository->>OrderJpaMapper: toDomain(orderJpaEntity)
    OrderJpaMapper-->>OrderRepository: Order
    OrderRepository-->>OrderService: Order

    OrderService->>OrderService: order.confirm(order.getId())
    Note right of OrderService: Raises OrderConfirmedEvent

    OrderService->>OrderService: publishDomainEvents(order)
    Note right of OrderService: Publishes domain events via Spring's ApplicationEventPublisher

    OrderService->>DomainEventHandler: OrderConfirmedEvent
    Note right of DomainEventHandler: @EventListener automatically handles the event
    DomainEventHandler->>DomainEventHandler: Creates OrderConfirmedIntegrationEvent
    DomainEventHandler->>OutboxRepository: save(integrationEvent)

    OrderService->>OrderRepository: save(updatedOrder)
    OrderRepository->>OrderJpaRepository: save(orderJpaEntity)
    OrderJpaRepository->>Database: UPDATE orders SET status='CONFIRMED'
    Database-->>OrderJpaRepository: updated order
    OrderJpaRepository-->>OrderRepository: OrderJpaEntity
    OrderRepository-->>OrderService: saved Order

    OutboxRepository->>OutboxJpaRepository: save(outboxJpaEntity)
    OutboxJpaRepository->>Database: INSERT INTO outbox
    Database-->>OutboxJpaRepository: saved message
    OutboxJpaRepository-->>OutboxRepository: OutboxJpaEntity
    OutboxRepository-->>DomainEventHandler: saved OutboxMessage

    OrderService-->>OrderController: confirmed Order
    OrderController-->>Client: 200 OK + OrderDto

    Note over OutboxProcessor, MessagePublisher: Background Processing (Async)

    OutboxProcessor->>OutboxRepository: findPending(batchSize)
    OutboxRepository->>OutboxJpaRepository: findPendingMessages()
    OutboxJpaRepository->>Database: SELECT FROM outbox WHERE status='PENDING'
    Database-->>OutboxJpaRepository: pending messages
    OutboxJpaRepository-->>OutboxRepository: List<OutboxMessage>
    OutboxRepository-->>OutboxProcessor: pending messages

    loop For each pending message
        OutboxProcessor->>MessagePublisher: publish(topic, payload)
        Note right of MessagePublisher: topic = "Order.OrderConfirmedIntegrationEvent"
        MessagePublisher-->>OutboxProcessor: published

        OutboxProcessor->>OutboxRepository: markProcessed(messageId)
        OutboxRepository->>OutboxJpaRepository: markAsProcessed()
        OutboxJpaRepository->>Database: UPDATE outbox SET status='PROCESSED'
        Database-->>OutboxJpaRepository: updated
        OutboxJpaRepository-->>OutboxRepository: success
        OutboxRepository-->>OutboxProcessor: marked as processed
    end

    Note over Client, Database: Transaction Boundary
    Note over OrderService, Database: Order update and outbox persistence in same transaction
    Note over OutboxProcessor, MessagePublisher: Outbox processing runs in separate transaction
```

### Key Points in the Flows:

#### Order Creation:
1. **Request Handling**: Client sends order data via REST API
2. **Domain Mapping**: DTO is converted to domain object (without orderNumber)
3. **Business Logic**: Order is validated and orderNumber is generated
4. **Domain Event**: OrderCreatedEvent is raised internally (not persisted to outbox)
5. **Persistence**: Order data is saved atomically
6. **Response**: Order is returned to client with generated orderNumber

#### Order Confirmation:
1. **Request Handling**: Client sends confirmation request via REST API
2. **Order Retrieval**: Order is fetched from repository by orderNumber
3. **Domain Logic**: Order.confirm() raises OrderConfirmedEvent
4. **Event Handling**: DomainEventHandler automatically listens for OrderConfirmedEvent and creates OrderConfirmedIntegrationEvent
5. **Persistence**: Order status update and integration event are saved atomically
6. **Background Processing**: OutboxProcessor picks up integration event and publishes it
7. **Reliability**: If message publishing fails, message remains in outbox for retry

### Transaction Boundaries:
- **Order Creation**: Single transaction for order persistence
- **Order Confirmation**: Single transaction for order update and outbox persistence (via DomainEventHandler)
- **Background Processing**: Separate transaction for message publishing and status updates
- **Idempotency**: Messages can be safely retried without duplication